-------------------------
Milestone I
-------------------------

Efficient Terrain Rendering and Chunking, Ryan Kenney

The terrain drawing function in MyGL ultimately draws every terrain generation zone in m_generatedTerrain through the Terrain draw function. At each tick, all terrain generation zones that are not around the player are deleted, and if there are too few, then new ones are created by creating or loading all of its chunks. To create the VBO data for a chunk, every block is checked and every adjacent empty block adds a face to the VBO. In order to only load one VBO, the position one was chosen; I attempted to create a separate vertex handle for referencing all info, but it ultimately caused the program to crash (although this was likely due to another problem fixed later). As such, the interleaved draw function references the data stored in the position VBO for all attributes.

Procedural Terrain, Lindsay Smith
In order to generate the terrain I first follow the descriptions for worley noise and perlin noise in the lecture slides. In the Terrain class I added functions that generated values using the noise functions. Then I used those values to determine heights for the grass biome and the mountain biomes each. The grass biome uses mainly worley noise, and the moutain biome uses mainly perlin noise. I then linearly interpolated those values with another perlin noise value in order to smooth between biomes. Depending on the height of the block I changed which type of block it should be as well. The grass biome has stone then dirt then grass. The mountains are all stone except for snow on the top. I set this by checking the height of the block being drawn. I also added an offset of the chunk x and chunk z to the createGenericChunk function so that the scene would properly render.

Player Physics
To check for player movement I have created boolean member variables for the Player class that flip to true if the corresponding key is pressed and false otherwise. Additionally, for camera rotation, I created member variables for the Camera class that store the current rotation and I use this to help calculate the new Camera axis. For creating a destroying and block, I used a grid march function that place/destroys the closest block the player is looking at. In flight mode the user can translate their local axis however, including clipping through terrain. But in non-flight mode the user cannot clip through terrain and will collide with any blocks in itâ€™s hotbox. 

-------------------------
Milestone II
-------------------------

Multithreaded Terrain Generation, Ryan Kenney

The terrain generation was reworked from the previous milestone to not render based on m_generatedTerrain, but to instead just render the chunks in the 3x3 zone range of the player. Upon startup, the 3x3 terrain generation zones surrounding the player are rendered normally to ensure that there are no physics issues and that everything is loaded on program start. From here, the 5x5 area of terrain generation zones are checked every tick and a thread is spawned to initialize each zone's chunks with blocks if that zone does not already exist. These chunks are pushed into a vector in Terrain, and the next function in the tick will add these chunks to Terrain (if the vector is not empty). The last function called each tick for terrain generation will check that every chunk in the 5x5 area has VBO data. If it does, a VBOWorker thread is spawned to create the VBO vectors. These workers are saved in a vector in Terrain, so the second part of this tick function checks each VBOWorker currently in Terrain to see if it is done generating the vectors. If a worker is done, its vectors are pushed to the GPU and the worker is removed from the worker vector.

-------------------------
Milestone III
-------------------------

NPCs and AI, Ryan Kenney

The primary NPC class is an extension of the Entity class from the previous sections, with a vector of general entities being used in MyGL to render any subclass of Entity. The child class "Goblin" was implemented to develop a working NPC class. First, a scene graph structure was used to create the physical model as it is rendered in MyGL. In the spirit of Minecraft, the now defunct Cube class was used as the Drawable for each node of the scene graph (with the minor changes of having the cube centered around 0 and built with a specified color). This scene graph structure is important, as it allows the model's componenets to move in the heart of the entity class, the tick() function. A Goblin has 3 possible states: idle, moving, and pathing. Using time seeded randomization, idle and moving are swapped between arbitrarily. When idle, the scene graph reverts to its default state. When moving, the entity's arms, legs, and neck swing back and forth. On top of this, the goblin will randomly change directions, which will affect the way it is facing as well as the way it will walk. Utilizing physics similar to the Player class, the goblin will attempt to navigate the environment. It will fall down blocks it walks off of, jump up 1 high blocks, and turn 180 degrees if it encounters a wall higher than 1 block. Under normal operations, they will simply oscillate between idle and moving while attempting to navigate what they encounter.

Along with this, a simple pathing algorithm was implemented that allows more complex pathing than what was mentioned before. Calling the command findPath(x,y,z) will have the goblin attempt to find a path to the coordinates (x,y,z). This algorithm has the goblin map out its surroundings with blocks that it can reach, concluding when it either finds the destination or realizes that it cannot be reached. This mapping is performed by keeping track of reachable blocks in a 15 block radius from the goblin's starting position. If neighboring blocks are reachable, then their neighbors are checked, and so on. Each block tracks its distance from the starting position, so once the target is reached a path is calculated by counting down until it returns to the origin block. If a viable path is found, the goblin is put into the pathing state, in which it will walk to each block of the path in order. Since these blocks form a connected line to the destination, the goblin will walk in cardinal directions to reach its goal. While the algorithm could be extended to handle more novel situations, it is currently designed with the expectation that floating or cave areas do not exist. It can, however, deal with non-level terrain in the pathing.

Finally, in order to test these components, 3 keybinds were added to MyGL. P generates the "pen", which creates a caged area with a goblin and its destination separated by an impassable wall, with the only opening being at the end of the room. The goblin will automatically calculate the path on button press and begin moving there. O tells all goblin entities within a 10 block radius of the player to path to the player's current location; while it seemed like pathing should be placed on a thread, this operation seemed to cause little slowdown even with a significant number of entities. Finally, U will simply spawn more goblins in on the player's location, where they will assume the normal wandering loop.
